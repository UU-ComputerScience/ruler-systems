{
{-# LANGUAGE BangPatterns #-}
module Sum where

import Control.Monad.Error
}

itf S
  visit v1
    inh l :: [Int]
  visit v2
    syn s :: Int

{
sum' = sem sum : S monad Either String
         visit v1
           clause sumNil
             match [] = lhs.l
             visit v2
               clause sumNil2
                 lhs.s = 0

           clause sumCons
             match (loc.x : loc.xs) = lhs.l
             attach v1 of tl : S = sum'
             tl.l = loc.xs
             invoke v1 of tl
             visit v2
               clause sumCons2
                 invoke v2 of tl
                 lhs.s = loc.x + tl.s
}

{
test :: [Int] -> Either String Int
test xs = do
  let inh1 = Inh_S_v1 { l_Inh_S_v1 = xs }
  syn1 <- invoke_S_v1 sum' inh1
  let inh2 = Inh_S_v2 {}
  syn2 <- invoke_S_v2 (next_S_v1 syn1) inh2
  let s = s_Syn_S_v2 syn2
  return s
  -- putStrLn ("sum: " ++ show s ++ " of: " ++ show xs)

main :: IO ()
main = putStrLn (show (test [1..100000]))
}
