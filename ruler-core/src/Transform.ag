MODULE {Transform} {transform} {}

PRAGMA genlinepragmas

INCLUDE "AstAG.ag"

imports
{
import Common
import Ast
import Errs
import Data.Sequence(Seq)
import qualified Data.Sequence as Seq
import Data.Map(Map)
import qualified Data.Map as Map
import Data.Set(Set)
import qualified Data.Set as Set
import Env
import Data.Monoid
import Data.List(nub, isPrefixOf, intersect)
import UU.Pretty
import Opts
import Data.Maybe
}


WRAPPER Program

{
transform :: Opts -> Program -> (Errs, String, String)
transform opts prog
  = (errs, txtPretty, txtTarget)
  where
    inh  = Inh_Program { opts_Inh_Program = opts }
    syn  = wrap_Program sem inh
    sem  = sem_Program prog
    errs = firstErrs [errs1_Syn_Program syn, errs2_Syn_Program syn, errs3_Syn_Program syn]
    
    resPretty = pretty_Syn_Program syn
    txtPretty = disp resPretty 999999 ""
    resTarget = pp_Syn_Program syn
    txtTarget = disp resTarget 999999 ""

firstErrs :: [Errs] -> Errs
firstErrs [] = Seq.empty
firstErrs (x:xs) = if Seq.null x then firstErrs xs else x
}


--
-- Transformations for various backends
--

ATTR Program [ | | pp, pretty : {PP_Doc} ]
SEM Program | Program
  lhs.pp     = empty   -- add output for additional backends
  lhs.pretty = @loc.ppId

INCLUDE "TargetHaskell.ag"


ATTR Program AllCodeBlocks [ opts : Opts | | ]


--
-- Collect errors
--

-- errs1: rudamentary checks
-- errs2: child checks
-- errs3: attribute checks

SET AllCode = Code Items Item SemVisit ClausesTop Clauses Clause Stmts Stmt BoundCode Pats Pat AttrTypePat AttrTypeCode
SET AllCodeBlocks = Blocks Block AllCode

ATTR Program AllCodeBlocks Data Cons Con [ | | errs1,errs2,errs3 USE {Seq.><} {Seq.empty} : {Errs} ]

SEM Program
  | Program  +errs1 = addDefErrs @blocks.gathItfs
             +errs1 = addDefErrs @blocks.gathVisits
             +errs1 = addDefErrs @blocks.gathInhs
             +errs1 = addDefErrs @blocks.gathSyns
             +errs1 = addDefErrs @blocks.gathNonterms
             +errs1 = addDefErrs @blocks.gathClauses
             +errs1 = addUseErrs @blocks.distItfs
             +errs1 = addUseErrs @blocks.distVisits
             +errs1 = addUseErrs @blocks.distChildDefs
             +errs1 = addDefErrs @blocks.gathDataCons
             +errs1 = addUseErrs @blocks.distDataCons
             +errs1 = addDefErrs' @blocks.gathDatas
             +errs3 = addDefUseErrs'' @blocks.gathDefs

{
addDefErrs :: Env QIdent v -> Errs -> Errs
addDefErrs env es
  = Seq.fromList (map (Err_Dup . map head) ds) Seq.>< es
  where ds = map (map fst) (dups env)

addUseErrs :: Env QIdent v -> Errs -> Errs
addUseErrs env es
  = Seq.fromList (map (Err_Missing . map head) ms) Seq.>< es
  where ms = missing env

addDefErrs' :: Env Ident v -> Errs -> Errs
addDefErrs' env es
  = Seq.fromList (map Err_Dup ds) Seq.>< es
  where ds = map (map fst) (dups env)

addUseErrs' :: Env Ident v -> Errs -> Errs
addUseErrs' env es
  = Seq.fromList (map Err_Missing ms) Seq.>< es
  where ms = missing env

addDefUseErrs' :: Env Ident v -> Errs -> Errs
addDefUseErrs' env = addDefErrs' env . addUseErrs' env

addDefErrs'' :: Env (Ident,Ident,Bool) v -> Errs -> Errs
addDefErrs'' env es
  = Seq.fromList (map mkDupErr ds) Seq.>< es
  where ds = map (map fst) (dups env)
        mkDupErr ((c,n,b):_) = Err_DupAttr b c n

addUseErrs'' :: Env (Ident,Ident,Bool) v -> Errs -> Errs
addUseErrs'' env es
  = Seq.fromList (map mkMissErr ms) Seq.>< es
  where ms = missing env
        mkMissErr ((c,n,b):_) = Err_MissingAttr b c n

addDefUseErrs'' :: Env (Ident,Ident,Bool) v -> Errs -> Errs
addDefUseErrs'' env = addDefErrs'' env . addUseErrs'' env
}

--
-- Standard duplication checks
--


{
type ItfEnv = Env QIdent ()
}

ATTR Blocks Block Itf ItfVisits ItfVisit [ | gathItfs : ItfEnv | ]

SEM Program
  | Program  blocks.gathItfs = emptyEnv

SEM Itf | Itf         +gathItfs = extend [@name] ()
SEM ItfVisit | Visit  +gathItfs = extend @loc.coItf ()

ATTR ItfVisits ItfVisit Attrs Attr [ itf : {QIdent} | | ]
SEM Itf | Itf  visits.itf = [@name]

{
type VisitEnv = Env QIdent ()
}

ATTR Blocks Block Itf ItfVisits ItfVisit [ | gathVisits : VisitEnv | ]

SEM Program
  | Program  blocks.gathVisits = emptyEnv

SEM ItfVisit | Visit
  +gathVisits = extend (@name : @lhs.itf) ()
  +gathVisits = extend (@name : @loc.coItf) ()


ATTR Attrs Attr [ visit : {QIdent} coItf : {QIdent} | | ]
SEM ItfVisit | Visit
  attrs.visit = @name : @lhs.itf
  loc.coItf = [mkCoIdent (head @lhs.itf) @name]

{
mkCoIdent :: Ident -> Ident -> Ident
mkCoIdent itf vis = Ident ("Co_" ++ show itf ++ "_" ++ show vis) (identPos itf)
}

{
type AttrEnv = Env QIdent String
}

ATTR Blocks Block Itf ItfVisits ItfVisit Attrs Attr [ | gathInhs, gathSyns : AttrEnv | ]

SEM Program
  | Program  blocks.gathInhs = emptyEnv
             blocks.gathSyns = emptyEnv

SEM Attr
  | Inh  +gathInhs = extend (@name : @lhs.itf) @type
         +gathSyns = extend (@name : @lhs.coItf) @type
  | Syn  +gathSyns = extend (@name : @lhs.itf) @type
         +gathInhs = extend (@name : @lhs.coItf) @type

ATTR VisitAttrs VisitAttr [ | gathChns : AttrEnv | ]

SEM SemVisit
  | Visit  attrs.gathChns = emptyEnv
           +errs1 = addDefErrs @attrs.gathChns

SEM VisitAttr | Chn  +gathChns = extend [@name] @type

{
type NontermEnv = Env QIdent ()
type ClausesEnv = Env QIdent ()
}

ATTR AllCodeBlocks [ | gathNonterms : NontermEnv gathClauses : ClausesEnv | ]
ATTR AllCode [ nonterm : {QIdent} | | ]

SEM Block | Section  code.nonterm  = [ident "<root>"]
SEM Item | Sem CoSem
  first.nonterm = [@name]

SEM Program
  | Program  blocks.gathNonterms = emptyEnv
             blocks.gathClauses  = emptyEnv

SEM Item
  | Sem CoSem  +gathNonterms = extend [@name] ()

SEM Clause
  | Clause  +gathClauses = extend (@name : @lhs.nonterm) ()

ATTR AllCodeBlocks [ allVisits : {Set Ident} | | ]

SEM Program | Program
  blocks.allVisits = Set.empty

SEM Item | Sem CoSem
  first.allVisits = Set.union (Set.fromList @loc.nextVisits) @lhs.allVisits

SEM Stmt | Attach
  +errs1 = ( if @name `Set.member` @lhs.allVisits
             then Seq.singleton $ Err_NameClash @name
             else Seq.empty
           ) Seq.><

ATTR Cons Con Fields Field [ data : Ident | | ]
ATTR Fields Field [ con : Ident | | ]
SEM Data | Data  cons.data  = @name
SEM Con | Con    fields.con = @name

{
type DataEnv  = Env Ident ()
type ConEnv   = Env QIdent FieldEnv
type FieldEnv = Env Ident String
}

ATTR Blocks Block Data Cons Con [ | gathDataCons : ConEnv | ]
ATTR AllCodeBlocks [ | distDataCons : ConEnv | ]

SEM Program | Program
  blocks.gathDataCons = emptyEnv
  blocks.distDataCons = @blocks.gathDataCons

SEM Con | Con
  +gathDataCons = extend [@name, @lhs.data] @fields.gathFields

ATTR Blocks Block Data [ | gathDatas : DataEnv | ]
SEM Program | Program  blocks.gathDatas = emptyEnv
SEM Data | Data        +gathDatas = extend @name ()

ATTR Fields Field [ | gathFields : FieldEnv | ]
SEM Con | Con
  fields.gathFields = emptyEnv
  +errs1 = addDefErrs' @fields.gathFields

SEM Field | Field
  +gathFields = extend @name @type

--
-- Standard usage checks
--

ATTR AllCodeBlocks [ | distItfs : ItfEnv | ]

SEM Program
  | Program  blocks.distItfs = @blocks.gathItfs

SEM Item | Sem CoSem
  +distItfs = snd . find [@tp] ()

ATTR AllCode Pats Pat AttrTypePat AttrTypeCode [ itf : QIdent | | ]
SEM Block
  | Section  code.itf = [ident "<root>"]

SEM Item
  | Sem      first.itf = [@tp]
  | CoSem    first.itf = [@loc.coItf]
             loc.coItf = mkCoIdent @tp @visit

ATTR AllCodeBlocks [ | distVisits : VisitEnv | ]

SEM Program
  | Program  blocks.distVisits = @blocks.gathVisits

SEM SemVisit
  | Visit  +distVisits = snd . find (@name : @lhs.itf) ()

SEM Stmt
  | Invoke  loc.unqualChildItf = head @loc.childItf
            loc.childVisits = Map.findWithDefault [] @loc.unqualChildItf @lhs.distVisitOrder
  | Attach  loc.childVisits = Map.findWithDefault [] @type @lhs.distVisitOrder
  | Invoke Attach
            +errs1 = ( if null @loc.childVisits || @visit `elem` @loc.childVisits
                       then Seq.empty else Seq.singleton (Err_UndefVisit @name @visit @loc.childVisits)) Seq.><

SEM Pat | AttrCon
  (loc.fieldEnv, lhs.distDataCons) = find [@con, @dt] emptyEnv @lhs.distDataCons
  loc.fields = assocs @loc.fieldEnv

--
-- Children defined
--

ATTR AllCodeBlocks [ | gathChildDefs, distChildDefs : {Env QIdent (QIdent, QIdent)} | ]

SEM Program | Program  blocks.gathChildDefs = emptyEnv
                       blocks.distChildDefs = @blocks.gathChildDefs

SEM Item
  | Sem CoSem
         loc.firstVisit = if null @loc.nextVisits then unknIdent else head @loc.nextVisits
         first.gathChildDefs = extend locQIdent (locQIdent, locQIdent)
                               $ extend visQIdent (visQIdent, visQIdent)
                               $ extend lhsQIdent ([@tp], [@loc.firstVisit, @tp])
                               $ enter @lhs.gathChildDefs
         (lhs.gathChildDefs, loc.localChildDefs) = leave @first.gathChildDefs
         -- don't addDefErrs on @loc.localChildDefs

         first.distChildDefs = enterWith @loc.localChildDefs @lhs.distChildDefs
         (lhs.distChildDefs, loc.localChildDefs') = leave @first.distChildDefs
         
         +errs1 = addUseErrs @loc.localChildDefs'
  | Attr    ((loc.childItf, loc.startVisit), lhs.gathChildDefs) = find [@child] (unknQIdent,unknQIdent) @lhs.gathChildDefs
  | Detach  ((loc.childItf, loc.startVisit), lhs.distChildDefs) = find [@name] (unknQIdent,unknQIdent) @lhs.distChildDefs

SEM Clauses
  | Cons  (hd.gathChildDefs, tl.gathChildDefs)    = split @lhs.gathChildDefs
          (lhs.gathChildDefs, loc.gathLChildDefs) = merge @hd.gathChildDefs @tl.gathChildDefs
          
          (hd.distChildDefs, tl.distChildDefs)    = splitWith @loc.gathLChildDefs @lhs.distChildDefs
          (lhs.distChildDefs, loc.distLChildDefs) = merge @hd.distChildDefs @tl.distChildDefs

          +errs1 = addUseErrs @loc.distLChildDefs

SEM Stmt
  | Attach  +gathChildDefs = extend [@name] ([@type],[@visit,@type])
  | Invoke  ((loc.childItf, loc.startVisit), code.gathChildDefs) = find [@name] (unknQIdent,unknQIdent) @lhs.gathChildDefs

SEM Pat
  | Attr    ((loc.childItf, loc.startVisit), lhs.distChildDefs) = find [@child] (unknQIdent,unknQIdent) @lhs.distChildDefs
  | AttrCon +gathChildDefs = extendTail [@name] (unknQIdent,unknQIdent)

{
unknIdent :: Ident
unknIdent = ident "<undefined>"

unknQIdent :: QIdent
unknQIdent = [unknIdent]

locQIdent :: QIdent
locQIdent = [locIdent]

lhsQIdent :: QIdent
lhsQIdent = [lhsIdent]

visQIdent :: QIdent
visQIdent = [visIdent]
}

--
-- Visit order
--

ATTR Blocks Block Itf ItfVisits ItfVisit [ | | gathVisitOrder USE {`mappend`} {mempty} : {Map Ident [Ident]} ]
ATTR ItfVisits ItfVisit [ | | gathVisitsOrder USE {++} {[]} : {[Ident]} ]

SEM Itf | Itf         +gathVisitOrder = Map.insert @name @visits.gathVisitsOrder
SEM ItfVisit | Visit  lhs.gathVisitsOrder = [@name]
                      lhs.gathVisitOrder = Map.singleton (head @loc.coItf) [@name]

ATTR AllCodeBlocks [ distVisitOrder : {Map Ident [Ident]} | | ]
ATTR SemVisit ClausesTop Clauses Clause [ nextVisits : {[Ident]} | | ]

SEM Program | Program  blocks.distVisitOrder = @blocks.gathVisitOrder
SEM Item | Sem         loc.nextVisits        = Map.findWithDefault [] @tp @lhs.distVisitOrder
         | CoSem       loc.nextVisits        = Map.findWithDefault [] @loc.coItf @lhs.distVisitOrder

SEM SemVisit
  | Visit  (loc.sequenceErrs, clauses.nextVisits) = checkVisitSequence @name @lhs.nextVisits
           +errs1 = @loc.sequenceErrs Seq.><
  | End    +errs1 = (if null @lhs.nextVisits then Seq.empty else Seq.singleton (Err_VisitsNotImpl @lhs.nonterm @lhs.nextVisits)) Seq.><

{
checkVisitSequence :: Ident -> [Ident] -> (Errs, [Ident])
checkVisitSequence _ [] = (Seq.empty, [])  -- dont report more errors if already erroneous
checkVisitSequence nm (nm' : nms)
  | nm == nm' = (Seq.empty, nms)
  | otherwise = (Seq.singleton $ Err_ExpVisit nm nm', [])  -- mismatch
}


--
-- Compute from bottom to top: the set of possible child visit sequences.
-- For each attach: check if all of these are a prefix of the range attached.
--

ATTR SemVisit ClausesTop Clauses Clause Stmts Stmt [ | | gathChildSeqs USE {`unionWithPlusplus`} {Map.empty} : {Map Ident [[Ident]]} ]

SEM Stmt | Invoke     lhs.gathChildSeqs = Map.singleton @name [[@visit]]
SEM Stmts | Cons      loc.gathChildSeqs = unionWithSequential @hd.gathChildSeqs @tl.gathChildSeqs
SEM Clause | Clause   loc.gathChildSeqs = unionWithSequential @stmts.gathChildSeqs @next.gathChildSeqs
SEM Clauses | Cons    lhs.gathChildSeqs = if @tl.isNil then @hd.gathChildSeqs else unionWithParallel @hd.gathChildSeqs @tl.gathChildSeqs
SEM SemVisit | Visit  lhs.gathChildSeqs = unionWithSequential @stmts.gathChildSeqs @clauses.gathChildSeqs

ATTR Clauses [ | | isNil : Bool ]
SEM Clauses
  | Nil   lhs.isNil = True
  | Cons  lhs.isNil = False

{
unionWithPlusplus :: Ord k => Map k [v] -> Map k [v] -> Map k [v]
unionWithParallel, unionWithSequential :: (Ord k, Ord v) => Map k [[v]] -> Map k [[v]] -> Map k [[v]]

unionWithPlusplus   = Map.unionWith (++)
unionWithParallel mp1 mp2 = Map.unionWith (++) mp1' mp2'
  where addleft  = Map.map (const [[]]) (mp2 `Map.difference` mp1)
        addright = Map.map (const [[]]) (mp1 `Map.difference` mp2)
        mp1' = addleft `Map.union` mp1
        mp2' = addright `Map.union` mp2
unionWithSequential = Map.unionWith (\[h] t -> map (h++) t)
}

ATTR AllCodeBlocks [ allChildSeqs : {Map Ident [[Ident]]} | | ]
ATTR Stmt Pats Pat AttrTypePat [ distChildSeqs : {Map Ident [[Ident]]} | | ]

SEM Program | Program  blocks.allChildSeqs = Map.empty

SEM Stmts | Cons  hd.distChildSeqs = @loc.gathChildSeqs
                  hd.allChildSeqs  = @loc.gathChildSeqs `Map.union` @lhs.allChildSeqs

SEM Stmt
  | Attach  loc.allowedVisits = dropWhile (/= @visit) @loc.childVisits
            loc.sequences = Map.findWithDefault [[]] @name @lhs.distChildSeqs
            +errs2 = Seq.fromList [ mkExpVisitErr s @loc.allowedVisits
                                  | s <- @loc.sequences, not (isPrefixOf s @loc.allowedVisits)] Seq.><

{
mkExpVisitErr (x : xs) (y : ys)
  | x == y    = mkExpVisitErr xs ys
  | otherwise = Err_ExpVisit x y
}

--
-- Compute from top to bottom: visits that have been invoked on children
-- Used to compute if the detach is the "next" visit of all visits invoked
-- so far
--

ATTR AllCodeBlocks [ gathInvokedVisits : {Map Ident [Ident]} | | ]

SEM Program | Program  blocks.gathInvokedVisits = Map.empty

ATTR Stmt [ | | gathInvokedVisits : {Map Ident [Ident]} ]

SEM Stmt | Invoke  +gathInvokedVisits = Map.insertWith (++) @name [@visit]

SEM Item
  | Detach  loc.invoked = Map.findWithDefault [] @name @lhs.gathInvokedVisits
            loc.unqualChildItf = head @loc.childItf
            loc.childVisits = Map.findWithDefault [] @loc.unqualChildItf @lhs.distVisitOrder
            loc.visit' = nextAfterInvoked @loc.invoked @loc.childVisits
            +errs2 = ( if @visit == @loc.visit'
                       then Seq.empty else Seq.singleton (Err_UndetachVisit @name @visit @visit')) Seq.><

{
nextAfterInvoked :: [Ident] -> [Ident] -> Ident
nextAfterInvoked (a:as) (b:bs)
  | a == b    = nextAfterInvoked as bs
  | otherwise = b
}


--
-- Attribute information: all syn/inh attrs per nonterm and per visit
--

{
type AttrMap = Map Ident (Map Ident String)
type VisitAttrMap = Map Ident AttrMap
}

ATTR Blocks Block Itf ItfVisits ItfVisit [ | | gathInhAttrs, gathSynAttrs USE {`mappend`} {mempty} : AttrMap ]
ATTR Blocks Block Itf ItfVisits ItfVisit [ | | gathVisitInhAttrs, gathVisitSynAttrs USE {`mappend`} {mempty} : VisitAttrMap ]
ATTR ItfVisits ItfVisit [ | | gathVisitsInhAttrs, gathVisitsSynAttrs USE {`mappend`} {mempty} : AttrMap ]
ATTR Attrs Attr [ | | gathVisitInhAttrs, gathVisitSynAttrs USE {`mappend`} {mempty} : {Map Ident String} ]

SEM Attr
  | Inh  lhs.gathVisitInhAttrs = Map.singleton @name @type
  | Syn  lhs.gathVisitSynAttrs = Map.singleton @name @type

SEM ItfVisit
  | Visit  lhs.gathVisitsInhAttrs = Map.singleton @name @attrs.gathVisitInhAttrs
           lhs.gathVisitsSynAttrs = Map.singleton @name @attrs.gathVisitSynAttrs
           lhs.gathVisitInhAttrs  = Map.singleton (head @loc.coItf) (Map.singleton @name @attrs.gathVisitSynAttrs)
           lhs.gathVisitSynAttrs  = Map.singleton (head @loc.coItf) (Map.singleton @name @attrs.gathVisitInhAttrs)
           lhs.gathInhAttrs = Map.singleton (head @loc.coItf) @attrs.gathVisitSynAttrs
           lhs.gathSynAttrs = Map.singleton (head @loc.coItf) @attrs.gathVisitInhAttrs

SEM Itf
  | Itf    +gathVisitInhAttrs = Map.insert @name @visits.gathVisitsInhAttrs
           +gathVisitSynAttrs = Map.insert @name @visits.gathVisitsSynAttrs

           +gathInhAttrs = Map.insert @name $ Map.unions $ Map.elems @visits.gathVisitsInhAttrs
           +gathSynAttrs = Map.insert @name $ Map.unions $ Map.elems @visits.gathVisitsSynAttrs

ATTR AllCodeBlocks [ distInhAttrs, distSynAttrs : AttrMap distVisitInhAttrs, distVisitSynAttrs : VisitAttrMap | | ]

SEM Program | Program
  blocks.distInhAttrs      = @blocks.gathInhAttrs
  blocks.distSynAttrs      = @blocks.gathSynAttrs
  blocks.distVisitInhAttrs = @blocks.gathVisitInhAttrs
  blocks.distVisitSynAttrs = @blocks.gathVisitSynAttrs

ATTR VisitAttrs VisitAttr [ | | gathVisitLocalAttrs USE {`mappend`} {mempty} : {Map Ident String} ]
ATTR Clauses Clause ClausesTop SemVisit [ | | gathVisitAttrs USE {`mappend`} {mempty} : {Map Ident (Map Ident String)} ]
ATTR AllCodeBlocks [ directVisitAttrs : {Map Ident (Map Ident String)} | | ]

SEM SemVisit | Visit   +gathVisitAttrs = Map.insert @name @attrs.gathVisitLocalAttrs
SEM VisitAttr | Chn    lhs.gathVisitLocalAttrs = Map.singleton @name @type
SEM Program | Program  blocks.directVisitAttrs = Map.empty
SEM Item | Sem CoSem   first.directVisitAttrs = @first.gathVisitAttrs

ATTR AllCodeBlocks [ directVisitLocalAttrs : {Map Ident String} | | ]
SEM Program | Program  blocks.directVisitLocalAttrs = Map.empty
SEM SemVisit | Visit   stmts.directVisitLocalAttrs   = @attrs.gathVisitLocalAttrs
                       clauses.directVisitLocalAttrs = @attrs.gathVisitLocalAttrs

--
-- Dispatch to AttrType
--

ATTR AttrTypePat AttrTypeCode [ child, name, childItf : Ident | | ]

SEM Pat | Attr
      inst.tp : AttrTypePat
      inst.tp = case identName @child of
                  s | s == "loc"                         -> AttrTypePat_ProdLocal
                    | s == "lhs"                         -> AttrTypePat_Lhs
                    | s == "vis"                         -> AttrTypePat_VisLocal
                    | @child `Set.member` @lhs.allVisits -> AttrTypePat_Visit
                    | otherwise                          -> AttrTypePat_Child
      tp.child    = @child
      tp.name     = @name
      tp.childItf = head @loc.childItf

SEM Item | Attr
      inst.tp : AttrTypeCode
      inst.tp = case identName @child of
                  s | s == "loc"                         -> AttrTypeCode_ProdLocal
                    | s == "lhs"                         -> AttrTypeCode_Lhs
                    | s == "vis"                         -> AttrTypeCode_VisLocal
                    | @child `Set.member` @lhs.allVisits -> AttrTypeCode_Visit
                    | otherwise                          -> AttrTypeCode_Child
      tp.child    = @child
      tp.name     = @name
      tp.childItf = head @loc.childItf

--
-- The real nasty part: attribute checks
-- (1) match/eval statements:
--      check def-attrs against defineable attributes
-- (2) statements with code:
--      check use-attrs against available attributes
-- (3) invoke statement:
--       check inh attrs against available attributes
--

-- computation of defineable attributes
--   * all syn attrs of lhs
--   * inh attrs of reachable visits of children
--       - design choice: only those visits that are common:
--         take intersection of visits in allChildSeqs 
--         and those attributes
--   * any local attribute is defineable

SEM AttrTypePat
  | Lhs  -- check if @lhs.name is a syn attr of @lhs.childItf
      loc.allowedDefs = Map.findWithDefault Map.empty (head @lhs.itf) @lhs.distSynAttrs
  | Child
      loc.visits      = common $ Map.findWithDefault [] @lhs.child @lhs.distChildSeqs
      loc.inhMap      = Map.findWithDefault Map.empty @lhs.childItf @lhs.distVisitInhAttrs
      loc.allowedDefs = Map.unions (map (\v -> Map.findWithDefault Map.empty v @loc.inhMap) @loc.visits)
  | Visit
      loc.allowedDefs = Map.findWithDefault Map.empty @lhs.child @lhs.directVisitAttrs
  | VisLocal
      loc.allowedDefs = @lhs.directVisitLocalAttrs
  | Lhs Child Visit VisLocal
      +errs2 = ( if Map.member @lhs.name @loc.allowedDefs
                 then Seq.empty
                 else Seq.singleton (Err_UndeclAttr @lhs.child @lhs.name) ) Seq.><

{
common :: [[Ident]] -> [Ident]
common []     = []
common [x]    = x
common (x:xs) = x `intersect` common xs
}

--
-- computation of available attributes
--
-- detect duplication + detect missing
-- we can use a single environment to keep track of the various
-- forms of attributes, because the "child"-name prevents overlap.
-- However, since scoping of visit-local attrs is different, we
-- put these in a separate environment
--

{
type At = (Ident,Ident,Bool)  -- True: inherited attr, False: syn attr
type DefsEnv = Env At (Maybe String)

locIdent, lhsIdent, visIdent :: Ident
locIdent = ident "loc"
lhsIdent = ident "lhs"
visIdent = ident "vis"
}

ATTR AllCodeBlocks [ | gathDefs, gathVisLocalDefs : DefsEnv | ]

SEM Program | Program  blocks.gathDefs         = emptyEnv
                       blocks.gathVisLocalDefs = emptyEnv

-- scoping
SEM Item | Sem CoSem
      first.gathDefs = enter @lhs.gathDefs
      first.gathVisLocalDefs = enter @lhs.gathVisLocalDefs
      (lhs.gathDefs, loc.localDefs) = leave @first.gathDefs
      (lhs.gathVisLocalDefs, loc.localVisLocalDefs) = leave @first.gathVisLocalDefs
      +errs3 = addDefUseErrs'' @loc.localDefs
      +errs3 = addDefUseErrs'' @loc.localVisLocalDefs

SEM Clauses | Cons
      (hd.gathDefs, tl.gathDefs) = split @lhs.gathDefs
      (hd.gathVisLocalDefs, tl.gathVisLocalDefs) = split @lhs.gathVisLocalDefs
      (lhs.gathDefs, loc.gathLDefs) = merge @hd.gathDefs @tl.gathDefs
      (lhs.gathVisLocalDefs, loc.gathVisLocalLDefs) = merge @hd.gathVisLocalDefs @tl.gathVisLocalDefs

      +errs3 = addDefUseErrs'' @loc.gathLDefs
      +errs3 = addDefUseErrs'' @loc.gathVisLocalLDefs

SEM SemVisit | Visit
      loc.ldefs1 = enter @lhs.gathVisLocalDefs
      stmts.gathVisLocalDefs = @loc.ldefs2
      (lhs.gathVisLocalDefs, loc.localVisLocalDefs) = leave @clauses.gathVisLocalDefs
      +errs3 = addDefUseErrs'' @loc.localVisLocalDefs

-- collect the local additions to compute the intersection of them
ATTR Clauses [ | | gathDefsAdds, gathVisLocalDefsAdds : {[DefsEnv]} ]

SEM Clauses
  | Cons  lhs.gathDefsAdds         = @loc.gathLDefs : @tl.gathDefsAdds
          lhs.gathVisLocalDefsAdds = @loc.gathVisLocalLDefs : @tl.gathVisLocalDefsAdds
  | Nil   lhs.gathDefsAdds         = []
          lhs.gathVisLocalDefsAdds = []

SEM ClausesTop
  | Top  +gathDefs         = push (strip $ intersection @clauses.gathDefsAdds)
         +gathVisLocalDefs = push (strip $ intersection @clauses.gathVisLocalDefsAdds)

-- Add chn attrs of visit and check that they are defined by all clauses
SEM SemVisit | Visit
      loc.ldefs2 = Map.foldWithKey (\n t -> extend (replPos @pos visIdent,replPos @pos n,True) (Just t)) @loc.ldefs1 @attrs.gathVisitLocalAttrs

ATTR ClausesTop Clauses Clause [ localAttrs : {Map Ident String} | | ]
SEM SemVisit | Visit  clauses.localAttrs = @attrs.gathVisitLocalAttrs

SEM Clause | Clause
  +gathVisLocalDefs = \env -> Map.foldWithKey (\n _ -> snd . find (replPos @pos visIdent,replPos @pos n,False) Nothing) env @lhs.localAttrs

-- Add inh attrs of visit and check that that the syns are defined in the end
SEM SemVisit | Visit
  loc.inhAttrMap = Map.findWithDefault Map.empty @name (Map.findWithDefault Map.empty (head @lhs.itf) @lhs.distVisitInhAttrs)
  stmts.gathDefs =  Map.foldWithKey (\n t -> extend (replPos @pos lhsIdent,replPos @pos n,True) (Just t)) @lhs.gathDefs @loc.inhAttrMap

ATTR ClausesTop Clauses Clause [ visit : Ident | | ]
SEM SemVisit | Visit  clauses.visit = @name

SEM Clause | Clause
  loc.synAttrMap = Map.findWithDefault Map.empty @lhs.visit (Map.findWithDefault Map.empty (head @lhs.itf) @lhs.distVisitSynAttrs)
  +gathDefs = \e -> Map.foldWithKey (\n _ -> snd . find (replPos @pos lhsIdent,replPos @pos n,False) Nothing) e @loc.synAttrMap

SEM AttrTypePat
  | VisLocal   +gathVisLocalDefs = extend (@lhs.child, @lhs.name, False) Nothing
  | ProdLocal  +gathDefs = extend (@lhs.child, @lhs.name, False) Nothing
  | Lhs        +gathDefs = extend (@lhs.child, @lhs.name, False) Nothing
  | Child      +gathDefs = extend (@lhs.child, @lhs.name, True)  Nothing
  | Visit      +gathDefs = extend (@lhs.child, @lhs.name, False) Nothing

SEM Pat | AttrCon
  +gathDefs = \env -> foldr (\(nm,tp) -> extend (@name, nm, False) (Just tp)) env @loc.fields

SEM AttrTypeCode
  | VisLocal   +gathVisLocalDefs = snd . find (@lhs.child, @lhs.name,True) Nothing
  | ProdLocal  +gathDefs = snd . find (@lhs.child, @lhs.name, False) Nothing
  | Lhs        +gathDefs = snd . find (@lhs.child, @lhs.name, True)  Nothing
  | Child      +gathDefs = snd . find (@lhs.child, @lhs.name, False) Nothing
  | Visit      +gathDefs = snd . find (@lhs.child, @lhs.name, True)  Nothing

{
replPos :: Pos -> Ident -> Ident
replPos p i = Ident (identName i) p
}

-- Check attributes defined for invoke, and bring attributes in scope (but not in the scope of rhs)
SEM Stmt | Invoke
  loc.inhAttrMap = Map.findWithDefault Map.empty @visit (Map.findWithDefault Map.empty @loc.unqualChildItf @lhs.distVisitInhAttrs)
  loc.synAttrMap = Map.findWithDefault Map.empty @visit (Map.findWithDefault Map.empty @loc.unqualChildItf @lhs.distVisitSynAttrs)
  code.gathDefs  = Map.foldWithKey (\n _ -> snd . find (@name,replPos @pos n,True) Nothing) @lhs.gathDefs @loc.inhAttrMap
  +gathDefs = \e -> Map.foldWithKey (\n t -> extend (@name,replPos @pos n,False) (Just t)) e @loc.synAttrMap


--
-- Some useful properties
--

ATTR ItfVisits ItfVisit [ | | firstVisit : Ident ]
SEM ItfVisit | Visit  lhs.firstVisit = @name
SEM ItfVisits
  | Cons  lhs.firstVisit = @hd.firstVisit
  | Nil   lhs.firstVisit = ident "nofirstvisit"

SEM ItfVisit
  | Visit  loc.itfNm = head @lhs.itf

SEM Attr
  | Inh Syn  loc.itfNm = head @lhs.itf
             loc.visNm = head @lhs.visit

ATTR ItfVisit [ mbNextVisit : {Maybe Ident} | | ]
ATTR ItfVisits [ | | mbNextVisit : {Maybe Ident} ]

SEM ItfVisits
  | Cons  hd.mbNextVisit  = @tl.mbNextVisit
          lhs.mbNextVisit = Just @hd.firstVisit
  | Nil   lhs.mbNextVisit = Nothing

SEM SemVisit | Visit  loc.itfNm = head @lhs.itf
SEM Clause | Clause   loc.itfNm = head @lhs.itf

ATTR SemVisit [ | | mbNextVisit : {Maybe Ident} ]
SEM SemVisit
  | Visit  lhs.mbNextVisit = Just @name
  | End    lhs.mbNextVisit = Nothing


--
-- Compute the next visit of the children in scope
--

ATTR SemVisit ClausesTop Clauses Clause Stmts Stmt [ | gathNextVisits : {Map Ident (Maybe Ident)} | ]

SEM Item | Sem CoSem
  first.gathNextVisits = Map.empty

SEM Stmt
  | Attach  +gathNextVisits = Map.insert @name (Just @visit)
  | Invoke  loc.mbNextVisit = visitAfter @visit @loc.childVisits
            +gathNextVisits = Map.insert @name @loc.mbNextVisit

{
visitAfter :: Ident -> [Ident] -> Maybe Ident
visitAfter nm (a : b : nms)
  | nm == a    = Just b
  | otherwise  = visitAfter nm (b : nms)
visitAfter _ _ = Nothing
}

ATTR ClausesTop Clauses Clause [ myNextVisits : {Map Ident (Maybe Ident)} | | ]
SEM SemVisit | Visit  loc.myNextVisits = Map.filter isJust @lhs.gathNextVisits

--
-- The identity-transformation: pretty-print of the AST
--

{
instance PP Ident where
  pp = text . identName
}

ATTR Block Itf ItfVisit Attr Data Con Field BoundCode Code Item SemVisit VisitAttr Clause Stmt Mode Bind Pat
  [ | | pp : {PP_Doc} ]

SEM Program
  | Program      loc.ppId = vlist @blocks.pps

SEM Block
  | Section      lhs.pp = "{" >-< @code.pp >-< "}"
  | Itf          lhs.pp = @itf.pp
  | Data         lhs.pp = @data.pp

SEM Itf
  | Itf          lhs.pp = "itf" >#< @name
                          >-< indent 2 (vlist @visits.pps)

SEM ItfVisit
  | Visit        lhs.pp = "visit" >#< @name
                          >-< indent 2 (vlist @attrs.pps)   

SEM Attr
  | Inh          lhs.pp = "inh" >#< @name >#< "::" >#< @type
  | Syn          lhs.pp = "syn" >#< @name >#< "::" >#< @type

SEM Data | Data
  lhs.pp = "data" >#< @name >-< indent 2 ( vlist @cons.pps )

SEM Con | Con
  lhs.pp = "con" >#< @name >-< indent 2 (vlist @fields.pps)

SEM Field | Field
  lhs.pp = @name >#< "::" >#< @type

SEM BoundCode
  | Code         lhs.pp = @bind.pp >#< @code.pp

SEM Code
  | Code         lhs.pp = vlist @items.pps

SEM Item
  | Plain        loc.pp = vlist (modifySpacing @loc.diff @lhs.indent @txt)
  | Attr         lhs.pp = addSpaces @loc.diff (@child >|< "." >|< @name)
  | Sem          lhs.pp = addSpaces @loc.diff ("sem" >#< @name >#< ":" >#< @tp
                                              >-< indent 2 @first.pp)
  | CoSem        lhs.pp = addSpaces @loc.diff ("cosem" >#< @name >#< ":" >#< @tp >#< @visit
                                              >-< indent 2 @first.pp)
  | Detach       lhs.pp = addSpaces @loc.diff ("detach" >#< @name >#< "of" >#< @visit)
  | Brackets     lhs.pp = addSpaces @loc.diff (text "{")
                          >-< vlist @items.pps
                          >-< addSpaces @loc.diff2 (text "}")

ATTR BoundCode Code Items Item SemVisit Stmts ClausesTop Clauses Clause Stmt [ indent : Int | | ]

SEM Block | Section   code.indent = 1
SEM BoundCode | Code  code.indent = column @pos + @bind.width

SEM Item
  | *            loc.diff  = column @pos - @lhs.indent
  | Brackets     loc.diff2 = column @posEnd - @lhs.indent

{
modifySpacing :: Int -> Int -> String -> [String]
modifySpacing n m s
  = take (length ls) (r : rs)
  where
    ls = lines s
    (f : fs) = ls ++ [""]
    r  = shift n f
    rs = map (drop (m-1)) fs
    
shift :: Int -> String -> String
shift n
  | n <= 0 = drop n
  | n > 0  = (replicate n ' ' ++)

addSpaces :: Int -> PP_Doc -> PP_Doc
addSpaces n d = text (replicate n ' ') >|< d
}

SEM SemVisit
  | Visit        lhs.pp = "visit" >#< @name
                          >-< indent 2 (   vlist @attrs.pps
                                       >-< vlist @stmts.pps
                                       >-< vlist @clauses.pps
                                       )
  | End          lhs.pp = empty

SEM VisitAttr
  | Chn          lhs.pp = "chn" >#< @name >#< "::" >#< @type

SEM Clause
  | Clause       lhs.pp = "clause" >#< @name
                          >-< indent 2 (   vlist @stmts.pps
                                       >-< @next.pp
                                       )

SEM Stmt
  | Eval         lhs.pp = @mode.pp >|< @pat.pp >#< @code.pp
  | Attach       lhs.pp = "attach" >#< @name >#< "of" >#< @visit >#< ":" >#< @type >#< @code.pp
  | Invoke       lhs.pp = "invoke" >#< @name >#< "of" >#< @visit >#< @code.pp

SEM Mode
  | Match        lhs.pp = text "match "
  | Assert       lhs.pp = empty

SEM Bind
  | Fun          lhs.pp = text "="
  | Monadic      lhs.pp = text "<-"

ATTR Bind [ | | width : Int ]
SEM Bind
  | Fun          lhs.width = 1
  | Monadic      lhs.width = 2

SEM Pat
  | Con          loc.needPar = needParens PrioCon @lhs.prio @lhs.isRight
  | Cons         loc.needPar = needParens PrioCons @lhs.prio @lhs.isRight

SEM Pat
  | Con          lhs.pp = addParens @loc.needPar (@name >#< hlist_sp @pats.pps)
  | AttrCon      lhs.pp = show @dt >|< "." >|< show @con >|< "@" >|< @name
  | Attr         lhs.pp = @child >|< "." >|< @name
  | Tup          lhs.pp = pp_block "(" ")" "," @pats.pps
  | List         lhs.pp = pp_block "[" "]" "," @pats.pps
  | Cons         lhs.pp = addParens @loc.needPar (@hd.pp >#< ":" >#< @tl.pp)
  | Underscore   lhs.pp = text "_"

ATTR Pat Pats [ prio : Prio | | ]
ATTR Pat [ isRight : Bool | | ]

SEM Stmt | Eval    pat.prio    = PrioTop
                   pat.isRight = False

SEM Pat
  | Con   pats.prio = PrioCon
  | Tup   pats.prio = PrioTop
  | List  pats.prio = PrioTop
  | Cons  hd.prio   = PrioCons
          tl.prio   = PrioCons

SEM Pats | Cons  hd.isRight = False

SEM Pat
  | Cons  hd.isRight = False
          tl.isRight = True

{
data Prio
  = PrioTop | PrioCons | PrioCon
  deriving (Eq, Ord)

needParens :: Prio -> Prio -> Bool -> Bool
needParens myPrio lhsPrio isRight = myPrio <= lhsPrio && (myPrio /= lhsPrio || isRight)

addParens :: Bool -> PP_Doc -> PP_Doc
addParens True  = pp_parens
addParens False = id
}

ATTR Blocks ItfVisits Attrs Items VisitAttrs ClausesTop Clauses Stmts Pats Cons Fields
  [ | | pps : {[PP_Doc]} ]

SEM Blocks
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM ItfVisits
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Attrs
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Cons
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Fields
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Items
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM VisitAttrs
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Clauses
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Stmts
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []

SEM Pats
  | Cons  lhs.pps = @hd.pp : @tl.pps
  | Nil   lhs.pps = []
