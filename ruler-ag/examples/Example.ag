-- AG Test File

{
module Example where


}

{
data Expr
  = Plus Expr Expr
  | Const Int
  | Funny
}

interface Eval
  visit select
    inputs  e
  visit compute
    outputs v
  visit funny
    outputs z

{
eval_expr =
  { sem :: Eval
      production
        visit select
          clause
            match { Const @loc.x } = { @lhs.e }
        visit compute
          clause
            eval  { @lhs.v       } = { @loc.x }
        visit funny
          clause
            eval  { @lhs.z       } = { 'a' }

      production
        visit select
          clause
            match { Plus @loc.e1 @loc.e2 } = { @lhs.e }

        visit compute
          clause
            child k1 :: Eval   = { eval_expr }
            child k1 : select  = { id }
            child k1 : compute = { id}
            
            child k2 :: Eval   = { eval_expr }
            child k2 : select  = { id }
            child k2 : compute = { id }

            eval { @k1.e}    = { @loc.e1 }
            eval { @k2.e}    = { @loc.e2 }
            eval { @lhs.v }  = { @k1.v + @k2.v }
        
        visit funny
          clause
            eval { @lhs.z }  = { 'b' }
      
      production
        visit select
          clause
        visit compute
          external { Just (Just 'c', 2) }
        
        visit funny
  }

main = let sem_select  = eval_expr
           (Just sem_compute)    = sem_select Funny   -- (Plus (Plus (Const 1) (Const 2)) (Const 3))
           (Just (sem_funny, v)) = sem_compute
           (Just z)              = sem_funny
       in  putStrLn (z : show v)
}
